Simplified Flow Structure
Trigger

Parent table when State = Closed Complete

Flow Steps:
1. Decision - Check Request Type

If current.request_type = "remove_authority" → Go to Remove Branch
Else (new/change) → Go to Process Branch


REMOVE BRANCH:
2A. Run Script in Set Flow Variable

Variable: removal_success (Boolean)

javascript(function() {
    var processor = new AuthorityLimitsProcessor();
    return processor.removeAuthorityLimit(current.job_code.toString());
})();

PROCESS BRANCH (New/Change):
2B. Parallel Flow - Get Both Child Records

Branch 1: Look Up Credit Child

Table: x_banun_bunow_si_0_credit_authority_limits
Condition: parent = current AND state = closed_complete


Branch 2: Look Up Non-Credit Child

Table: x_banun_bunow_si_0_non_credit_authority_limits
Condition: parent = current AND state = closed_complete



3B. Set Flow Variable with Script - Process Records

Variable: update_success (Boolean)

javascript(function() {
    var processor = new AuthorityLimitsProcessor();
    
    // fd_data contains the records from the parallel lookups
    var creditChildSysId = fd_data.lookup_credit_result ? fd_data.lookup_credit_result.sys_id : null;
    var nonCreditChildSysId = fd_data.lookup_non_credit_result ? fd_data.lookup_non_credit_result.sys_id : null;
    
    return processor.processAuthorityLimits(
        current.job_code.toString(),
        current.request_type.toString(),
        creditChildSysId,
        nonCreditChildSysId,
        current.sys_id
    );
})();

Script Include: AuthorityLimitsProcessor
javascriptvar AuthorityLimitsProcessor = Class.create();
AuthorityLimitsProcessor.prototype = {
    initialize: function() {},
    
    processAuthorityLimits: function(jobCode, requestType, creditChildId, nonCreditChildId, parentId) {
        try {
            // Get values from child records
            var creditValues = this._getCreditValues(creditChildId);
            var nonCreditValues = this._getNonCreditValues(nonCreditChildId);
            
            // Check if limit already exists
            var existingGr = new GlideRecord('x_banun_bunow_si_0_authority_limits');
            existingGr.addQuery('job_code', jobCode);
            existingGr.addQuery('active', true);
            existingGr.query();
            
            if (existingGr.next()) {
                // Update existing
                return this._updateLimit(existingGr, creditValues, nonCreditValues, parentId, requestType);
            } else {
                // Create new
                return this._createLimit(jobCode, creditValues, nonCreditValues, parentId, requestType);
            }
        } catch (e) {
            gs.error('AuthorityLimitsProcessor Error: ' + e.message);
            return false;
        }
    },
    
    removeAuthorityLimit: function(jobCode) {
        try {
            var gr = new GlideRecord('x_banun_bunow_si_0_authority_limits');
            gr.addQuery('job_code', jobCode);
            gr.addQuery('active', true);
            gr.query();
            
            while (gr.next()) {
                gr.active = false; // Soft delete
                gr.update();
            }
            return true;
        } catch (e) {
            gs.error('Remove Authority Limit Error: ' + e.message);
            return false;
        }
    },
    
    _getCreditValues: function(creditChildId) {
        if (!creditChildId) return null;
        
        var gr = new GlideRecord('x_banun_bunow_si_0_credit_authority_limits');
        if (gr.get(creditChildId)) {
            return {
                overdraft_external_accounts: gr.getValue('overdraft_external_accounts'),
                overdraft_internal_accounts: gr.getValue('overdraft_internal_accounts'),
                unavailable_funds_external_accounts: gr.getValue('unavailable_funds_external_accounts'),
                unavailable_funds_internal_accounts: gr.getValue('unavailable_funds_internal_accounts')
            };
        }
        return null;
    },
    
    _getNonCreditValues: function(nonCreditChildId) {
        if (!nonCreditChildId) return null;
        
        var gr = new GlideRecord('x_banun_bunow_si_0_non_credit_authority_limits');
        if (gr.get(nonCreditChildId)) {
            return {
                disbursement_ach: gr.getValue('disbursement_ach'),
                disbursement_wire_transfer_external: gr.getValue('disbursement_wire_transfer_external'),
                disbursement_wire_transfer_internal: gr.getValue('disbursement_wire_transfer_internal'),
                disbursement_official_checks_external: gr.getValue('disbursement_official_checks_external'),
                disbursement_official_checks_internal: gr.getValue('disbursement_official_checks_internal'),
                check_cashing_on_us: gr.getValue('check_cashing_on_us'),
                check_cashing_not_on_us: gr.getValue('check_cashing_not_on_us'),
                remote_deposit: gr.getValue('remote_deposit'),
                treasury_solutions_company_wire_limits: gr.getValue('treasury_solutions_company_wire_limits'),
                fx_wire_limits: gr.getValue('fx_wire_limits')
            };
        }
        return null;
    },
    
    _updateLimit: function(existingGr, creditValues, nonCreditValues, parentId, requestType) {
        if (creditValues) {
            for (var key in creditValues) {
                existingGr[key] = creditValues[key];
            }
        }
        
        if (nonCreditValues) {
            for (var key in nonCreditValues) {
                existingGr[key] = nonCreditValues[key];
            }
        }
        
        existingGr.last_updated_from_request = parentId;
        existingGr.last_update_type = requestType;
        existingGr.update();
        
        return true;
    },
    
    _createLimit: function(jobCode, creditValues, nonCreditValues, parentId, requestType) {
        var newGr = new GlideRecord('x_banun_bunow_si_0_authority_limits');
        newGr.initialize();
        newGr.job_code = jobCode;
        newGr.active = true;
        
        if (creditValues) {
            for (var key in creditValues) {
                newGr[key] = creditValues[key];
            }
        }
        
        if (nonCreditValues) {
            for (var key in nonCreditValues) {
                newGr[key] = nonCreditValues[key];
            }
        }
        
        newGr.created_from_request = parentId;
        newGr.last_update_type = requestType;
        var sysId = newGr.insert();
        
        return sysId ? true : false;
    }
};
Much cleaner! The flow is simple, and all the logic is in the Script Include. What do you think?
