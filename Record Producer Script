// Authority Widget Record Producer Script
// Processes widget data and creates parent/child authority records with original value tracking

var parentId = current.getUniqueValue();
var shouldProceed = true; // Flag to control processing flow

// Check authority limits validation first
var requestType = producer.request_type ? producer.request_type.toString() : '';
var jobCode = producer.job_code ? producer.job_code.toString() : '';

gs.info('SIGNATURE LOG: Starting script - Request Type: ' + requestType + ', Job Code: ' + jobCode);

// If we have both request type and job code, check if this combination should be blocked
if (requestType && jobCode) {
    // Get authority limits to check if they exist
    var limitsExist = false;
    var limitGr = new GlideRecord('x_banun_bunow_si_0_authority_limits');
    limitGr.addQuery('job_code', jobCode);
    limitGr.addQuery('active', true);
    limitGr.query();
    if (limitGr.hasNext()) {
        limitsExist = true;
    }

    var shouldBlock = false;
    var blockMessage = '';

    // Get job code display value
    var jobCodeDisplay = '';
    var jobGr = new GlideRecord('x_banun_rbac_job_code');
    if (jobGr.get(jobCode)) {
        jobCodeDisplay = jobGr.getDisplayValue();
    }

    // Check blocking conditions
    if (requestType === 'new_authority' && limitsExist) {
        shouldBlock = true;
        blockMessage = 'Authority limits already exist for job code ' + jobCodeDisplay + '. Please submit a "Change to Existing Authority" request instead.';
    } else if (requestType === 'change_to_existing_authority' && !limitsExist) {
        shouldBlock = true;
        blockMessage = 'No authority limits found for job code ' + jobCodeDisplay + '. Please submit a "New Authority" request instead.';
    } else if (requestType === 'remove_authority' && !limitsExist) {
        shouldBlock = true;
        blockMessage = 'No existing authority limits found for job code ' + jobCodeDisplay + '. Cannot proceed with removal request.';
    }

    if (shouldBlock) {
        gs.addErrorMessage(blockMessage);
        current.setAbortAction(true);
        shouldProceed = false; // Prevent further processing
    }
}

// Only proceed if authority limits validation passed
if (shouldProceed) {

    var validationPassed = false;

    // Handle remove_authority validation on server side
    if (requestType === 'remove_authority') {
        // For remove requests, completely ignore client validation and only check business justification
        var businessNeed = producer.overall_business_need ? producer.overall_business_need.toString().trim() : '';
        if (businessNeed && businessNeed.length > 0) {
            validationPassed = true;
        } else {
            gs.addErrorMessage('Overall Business Need is required');
            current.setAbortAction(true);
            validationPassed = false;
        }
    } else {
        // For other request types, use the client validation result
        var formIsValid = producer.form_is_valid ? producer.form_is_valid.toString().trim() : 'false';
        validationPassed = (formIsValid === 'true' || formIsValid === true || producer.form_is_valid === true);

        // If client validation failed, show the client errors
        if (!validationPassed) {
            var errors = producer.form_validation_errors ? producer.form_validation_errors.toString().split('|') : ['Form validation failed'];
            gs.addErrorMessage('Please correct the following errors: ' + errors.join('; '));
            current.setAbortAction(true);
        }
    }


    if (validationPassed) {
        // Set job code string fields on parent record for display purposes
        if (producer.job_code) {
            var jobCodeGR = new GlideRecord('x_banun_rbac_job_code');
            if (jobCodeGR.get(producer.job_code)) {
                current.setValue('job_code_string', jobCodeGR.getValue('job_code'));
                current.setValue('job_function_description', jobCodeGR.getValue('job_function_description'));
            }
        }

        // NEW: Get existing limits for ALL request types (we'll use them differently based on type)
        var existingLimits = {};
        var existingLimitsFound = false;

        if (producer.job_code) {
            var existingLimitsGr = new GlideRecord('x_banun_bunow_si_0_authority_limits');
            existingLimitsGr.addQuery('job_code', producer.job_code);
            existingLimitsGr.addQuery('active', true);
            existingLimitsGr.orderByDesc('sys_created_on');
            existingLimitsGr.setLimit(1);
            existingLimitsGr.query();

            if (existingLimitsGr.next()) {
                existingLimitsFound = true;
                // Store all existing values
                existingLimits = {
                    // Non-credit limits
                    disbursement_ach: existingLimitsGr.getValue('disbursement_ach'),
                    disbursement_wire_transfer_external: existingLimitsGr.getValue('disbursement_wire_transfer_external'),
                    disbursement_wire_transfer_internal: existingLimitsGr.getValue('disbursement_wire_transfer_internal'),
                    disbursement_official_checks_external: existingLimitsGr.getValue('disbursement_official_checks_external'),
                    disbursement_official_checks_internal: existingLimitsGr.getValue('disbursement_official_checks_internal'),
                    check_cashing_on_us: existingLimitsGr.getValue('check_cashing_on_us'),
                    check_cashing_not_on_us: existingLimitsGr.getValue('check_cashing_not_on_us'),
                    remote_deposit: existingLimitsGr.getValue('remote_deposit'),
                    treasury_solutions_company_wire_limits: existingLimitsGr.getValue('treasury_solutions_company_wire_limits'),
                    fx_wire_limits: existingLimitsGr.getValue('fx_wire_limits'),
                    // Credit limits
                    overdraft_external_accounts: existingLimitsGr.getValue('overdraft_external_accounts'),
                    overdraft_internal_accounts: existingLimitsGr.getValue('overdraft_internal_accounts'),
                    unavailable_funds_external_accounts: existingLimitsGr.getValue('unavailable_funds_external_accounts'),
                    unavailable_funds_internal_accounts: existingLimitsGr.getValue('unavailable_funds_internal_accounts')
                };
                
                gs.info('SIGNATURE LOG: Found existing limits for job code ' + producer.job_code);
            }
        }

        // Handle REMOVE AUTHORITY request - copy existing limits as child records
        if (requestType === 'remove_authority' && producer.job_code && existingLimitsFound) {

            // Helper function to check if a value is greater than zero
            function isGreaterThanZero(value) {
                if (!value) return false;
                var numValue = parseFloat(value);
                return !isNaN(numValue) && numValue > 0;
            }

            // Check if there are any non-zero non-credit values
            var hasNonCreditValues =
                isGreaterThanZero(existingLimits.disbursement_ach) ||
                isGreaterThanZero(existingLimits.disbursement_wire_transfer_external) ||
                isGreaterThanZero(existingLimits.disbursement_wire_transfer_internal) ||
                isGreaterThanZero(existingLimits.disbursement_official_checks_external) ||
                isGreaterThanZero(existingLimits.disbursement_official_checks_internal) ||
                isGreaterThanZero(existingLimits.check_cashing_on_us) ||
                isGreaterThanZero(existingLimits.check_cashing_not_on_us) ||
                isGreaterThanZero(existingLimits.remote_deposit) ||
                isGreaterThanZero(existingLimits.treasury_solutions_company_wire_limits) ||
                isGreaterThanZero(existingLimits.fx_wire_limits);

            // Check if there are any non-zero credit values
            var hasCreditValues =
                isGreaterThanZero(existingLimits.overdraft_external_accounts) ||
                isGreaterThanZero(existingLimits.overdraft_internal_accounts) ||
                isGreaterThanZero(existingLimits.unavailable_funds_external_accounts) ||
                isGreaterThanZero(existingLimits.unavailable_funds_internal_accounts);

            // Create non-credit child record ONLY if there are non-zero non-credit values
            if (hasNonCreditValues) {
                var nonCreditGR = new GlideRecord('x_banun_bunow_si_0_non_credit_authority_limits');
                nonCreditGR.initialize();
                nonCreditGR.parent = parentId;
                nonCreditGR.job_code = producer.job_code;

                // Copy all non-credit values from existing limit
                var nonCreditFields = [
                    'disbursement_ach',
                    'disbursement_wire_transfer_external',
                    'disbursement_wire_transfer_internal',
                    'disbursement_official_checks_external',
                    'disbursement_official_checks_internal',
                    'check_cashing_on_us',
                    'check_cashing_not_on_us',
                    'remote_deposit',
                    'treasury_solutions_company_wire_limits',
                    'fx_wire_limits'
                ];

                for (var i = 0; i < nonCreditFields.length; i++) {
                    var fieldName = nonCreditFields[i];
                    var fieldValue = existingLimits[fieldName];
                    if (fieldValue) {
                        // For REMOVE: Only set regular fields (NOT original fields)
                        nonCreditGR[fieldName] = fieldValue;
                        // NOT setting original_ fields for REMOVE requests
                    }
                }

                var nonCreditSysId = nonCreditGR.insert();
            }

            // Create credit child record ONLY if there are non-zero credit values
            if (hasCreditValues) {
                var creditGR = new GlideRecord('x_banun_bunow_si_0_credit_authority_limits');
                creditGR.initialize();
                creditGR.parent = parentId;
                creditGR.job_code = producer.job_code;

                // Copy all credit values from existing limit
                var creditFields = [
                    'overdraft_external_accounts',
                    'overdraft_internal_accounts',
                    'unavailable_funds_external_accounts',
                    'unavailable_funds_internal_accounts'
                ];

                for (var j = 0; j < creditFields.length; j++) {
                    var creditFieldName = creditFields[j];
                    var creditFieldValue = existingLimits[creditFieldName];
                    if (creditFieldValue) {
                        // For REMOVE: Only set regular fields (NOT original fields)
                        creditGR[creditFieldName] = creditFieldValue;
                        // NOT setting original_ fields for REMOVE requests
                    }
                }

                var creditSysId = creditGR.insert();
            }

        } else if (requestType !== 'remove_authority' && producer.authority_types && producer.authority_data) {
            gs.info('SIGNATURE LOG: Processing NEW or CHANGE request');
            gs.info('SIGNATURE LOG: Authority types: ' + producer.authority_types);
            
            // Process authority data for NEW and CHANGE requests (existing logic)
            var authority_types = producer.authority_types.toString().split('|');
            var authority_data_strings = producer.authority_data.toString().split('|');

            // Create child records for each authority type selected
            for (var i = 0; i < authority_types.length; i++) {
                var authorityType = authority_types[i];
                var authorityDataStr = authority_data_strings[i];

                try {
                    var authorityData = JSON.parse(authorityDataStr);
                    gs.info('SIGNATURE LOG: Processing authority type: ' + authorityType);

                    if (authorityType === 'non_credit') {
                        gs.info('SIGNATURE LOG: Creating non-credit record');
                        
                        // Create non-credit authority limit record
                        var nonCreditGR = new GlideRecord('x_banun_bunow_si_0_non_credit_authority_limits');
                        nonCreditGR.initialize();
                        nonCreditGR.parent = parentId;
                        if (producer.job_code) {
                            nonCreditGR.job_code = producer.job_code;
                        }

                        // Track if any values changed
                        var hasNonCreditChanges = false;

                        // Set the REQUESTED values (what the user submitted)
                        if (authorityData.disbursement_ach)
                            nonCreditGR.disbursement_ach = authorityData.disbursement_ach;
                        if (authorityData.disbursement_wire_transfer_external)
                            nonCreditGR.disbursement_wire_transfer_external = authorityData.disbursement_wire_transfer_external;
                        if (authorityData.disbursement_wire_transfer_internal)
                            nonCreditGR.disbursement_wire_transfer_internal = authorityData.disbursement_wire_transfer_internal;
                        if (authorityData.disbursement_official_checks_external)
                            nonCreditGR.disbursement_official_checks_external = authorityData.disbursement_official_checks_external;
                        if (authorityData.disbursement_official_checks_internal)
                            nonCreditGR.disbursement_official_checks_internal = authorityData.disbursement_official_checks_internal;
                        if (authorityData.check_cashing_on_us)
                            nonCreditGR.check_cashing_on_us = authorityData.check_cashing_on_us;
                        if (authorityData.check_cashing_not_on_us)
                            nonCreditGR.check_cashing_not_on_us = authorityData.check_cashing_not_on_us;
                        if (authorityData.remote_deposit)
                            nonCreditGR.remote_deposit = authorityData.remote_deposit;
                        if (authorityData.treasury_solutions_company_wire_limits)
                            nonCreditGR.treasury_solutions_company_wire_limits = authorityData.treasury_solutions_company_wire_limits;
                        if (authorityData.fx_wire_limits)
                            nonCreditGR.fx_wire_limits = authorityData.fx_wire_limits;

                        // Set the ORIGINAL values for CHANGE requests and check for changes
                        if (requestType === 'change_to_existing_authority' && existingLimitsFound) {
                            gs.info('SIGNATURE LOG: This is a CHANGE request with existing limits - checking for changes');
                            
                            // Set all original values
                            nonCreditGR.original_disbursement_ach = existingLimits.disbursement_ach || '';
                            nonCreditGR.original_disbursement_wire_transfer_external = existingLimits.disbursement_wire_transfer_external || '';
                            nonCreditGR.original_disbursement_wire_transfer_internal = existingLimits.disbursement_wire_transfer_internal || '';
                            nonCreditGR.original_disbursement_official_checks_external = existingLimits.disbursement_official_checks_external || '';
                            nonCreditGR.original_disbursement_official_checks_internal = existingLimits.disbursement_official_checks_internal || '';
                            nonCreditGR.original_check_cashing_on_us = existingLimits.check_cashing_on_us || '';
                            nonCreditGR.original_check_cashing_not_on_us = existingLimits.check_cashing_not_on_us || '';
                            nonCreditGR.original_remote_deposit = existingLimits.remote_deposit || '';
                            nonCreditGR.original_treasury_solutions_company_wire_limits = existingLimits.treasury_solutions_company_wire_limits || '';
                            nonCreditGR.original_fx_wire_limits = existingLimits.fx_wire_limits || '';

                            // Check if any values actually changed
                            var nonCreditFieldsToCheck = [
                                'disbursement_ach',
                                'disbursement_wire_transfer_external',
                                'disbursement_wire_transfer_internal',
                                'disbursement_official_checks_external',
                                'disbursement_official_checks_internal',
                                'check_cashing_on_us',
                                'check_cashing_not_on_us',
                                'remote_deposit',
                                'treasury_solutions_company_wire_limits',
                                'fx_wire_limits'
                            ];

                            // Helper function to normalize values for comparison
                            // Treats 0, "0", "", null, undefined as equivalent
                            function normalizeValue(val) {
                                if (!val || val === '0' || val === 0) {
                                    return '0';  // Normalize all empty/zero values to '0'
                                }
                                return val.toString();
                            }

                            for (var ncf = 0; ncf < nonCreditFieldsToCheck.length; ncf++) {
                                var fieldName = nonCreditFieldsToCheck[ncf];
                                var newValue = normalizeValue(authorityData[fieldName]);
                                var originalValue = normalizeValue(existingLimits[fieldName]);
                                
                                gs.info('SIGNATURE LOG: Comparing field ' + fieldName + ' - New (normalized): "' + newValue + '" vs Original (normalized): "' + originalValue + '"');

                                if (newValue !== originalValue) {
                                    hasNonCreditChanges = true;
                                    gs.info('SIGNATURE LOG: Field ' + fieldName + ' has changed!');
                                    break;
                                }
                            }

                            // If no changes detected, set to Closed Complete BEFORE insert
                            if (!hasNonCreditChanges) {
                                gs.info('SIGNATURE LOG: NO CHANGES detected for non-credit, attempting auto-close');
                                
                                // Use direct property assignment since record isn't inserted yet
                                nonCreditGR.state = 3;
                                nonCreditGR.stage = 'closed';
                                nonCreditGR.approval = 'approved';
                                nonCreditGR.work_notes = 'Auto-closed: No changes detected from existing values';
                                
                                gs.info('SIGNATURE LOG: Set state=' + nonCreditGR.state + ', stage=' + nonCreditGR.stage + ', approval=' + nonCreditGR.approval);
                                
                                var nonCreditSysId = nonCreditGR.insert();
                                gs.info('SIGNATURE LOG: Created non-credit record ' + nonCreditSysId + ' with auto-close attempt');
                                
                                // Double-check and update if needed
                                var checkGR = new GlideRecord('x_banun_bunow_si_0_non_credit_authority_limits');
                                if (checkGR.get(nonCreditSysId)) {
                                    gs.info('SIGNATURE LOG: Re-checking record - state=' + checkGR.getValue('state') + ', stage=' + checkGR.getValue('stage') + ', approval=' + checkGR.getValue('approval'));
                                    
                                    if (checkGR.getValue('state') != '3' || checkGR.getValue('stage') != 'closed') {
                                        gs.info('SIGNATURE LOG: State not correctly set, updating via update()');
                                        checkGR.state = 3;
                                        checkGR.stage = 'closed';
                                        checkGR.approval = 'approved';
                                        checkGR.update();
                                        gs.info('SIGNATURE LOG: Update completed');
                                    } else {
                                        gs.info('SIGNATURE LOG: State was correctly set, no update needed');
                                    }
                                } else {
                                    gs.info('SIGNATURE LOG: ERROR - Could not retrieve record ' + nonCreditSysId);
                                }
                            } else {
                                gs.info('SIGNATURE LOG: Changes detected for non-credit, normal insert');
                                nonCreditGR.insert();
                            }
                        } else {
                            gs.info('SIGNATURE LOG: NEW request or no existing limits, normal insert');
                            nonCreditGR.insert();
                        }

                    } else if (authorityType === 'credit') {
                        gs.info('SIGNATURE LOG: Creating credit record');
                        
                        // Create credit authority limit record
                        var creditGR = new GlideRecord('x_banun_bunow_si_0_credit_authority_limits');
                        creditGR.initialize();
                        creditGR.parent = parentId;
                        if (producer.job_code) {
                            creditGR.job_code = producer.job_code;
                        }

                        // Track if any values changed
                        var hasCreditChanges = false;

                        // Set the REQUESTED values (what the user submitted)
                        if (authorityData.overdraft_internal_accounts)
                            creditGR.overdraft_internal_accounts = authorityData.overdraft_internal_accounts;
                        if (authorityData.overdraft_external_accounts)
                            creditGR.overdraft_external_accounts = authorityData.overdraft_external_accounts;
                        if (authorityData.unavailable_funds_internal_accounts)
                            creditGR.unavailable_funds_internal_accounts = authorityData.unavailable_funds_internal_accounts;
                        if (authorityData.unavailable_funds_external_accounts)
                            creditGR.unavailable_funds_external_accounts = authorityData.unavailable_funds_external_accounts;

                        // Set the ORIGINAL values for CHANGE requests and check for changes
                        if (requestType === 'change_to_existing_authority' && existingLimitsFound) {
                            gs.info('SIGNATURE LOG: This is a CHANGE request with existing limits - checking for credit changes');
                            
                            // Set all original values
                            creditGR.original_overdraft_internal_accounts = existingLimits.overdraft_internal_accounts || '';
                            creditGR.original_overdraft_external_accounts = existingLimits.overdraft_external_accounts || '';
                            creditGR.original_unavailable_funds_internal_accounts = existingLimits.unavailable_funds_internal_accounts || '';
                            creditGR.original_unavailable_funds_external_accounts = existingLimits.unavailable_funds_external_accounts || '';

                            // Check if any values actually changed
                            var creditFieldsToCheck = [
                                'overdraft_internal_accounts',
                                'overdraft_external_accounts',
                                'unavailable_funds_internal_accounts',
                                'unavailable_funds_external_accounts'
                            ];

                            // Helper function to normalize values for comparison
                            // Treats 0, "0", "", null, undefined as equivalent
                            function normalizeValueCredit(val) {
                                if (!val || val === '0' || val === 0) {
                                    return '0';  // Normalize all empty/zero values to '0'
                                }
                                return val.toString();
                            }

                            for (var cf = 0; cf < creditFieldsToCheck.length; cf++) {
                                var fieldName = creditFieldsToCheck[cf];
                                var newValue = normalizeValueCredit(authorityData[fieldName]);
                                var originalValue = normalizeValueCredit(existingLimits[fieldName]);
                                
                                gs.info('SIGNATURE LOG: Comparing credit field ' + fieldName + ' - New (normalized): "' + newValue + '" vs Original (normalized): "' + originalValue + '"');

                                if (newValue !== originalValue) {
                                    hasCreditChanges = true;
                                    gs.info('SIGNATURE LOG: Credit field ' + fieldName + ' has changed!');
                                    break;
                                }
                            }

                            // If no changes detected, set to Closed Complete BEFORE insert
                            if (!hasCreditChanges) {
                                gs.info('SIGNATURE LOG: NO CHANGES detected for credit, attempting auto-close');
                                
                                // Use direct property assignment since record isn't inserted yet
                                creditGR.state = 3;
                                creditGR.stage = 'closed';
                                creditGR.approval = 'approved';
                                creditGR.work_notes = 'Auto-closed: No changes detected from existing values';
                                
                                gs.info('SIGNATURE LOG: Set state=' + creditGR.state + ', stage=' + creditGR.stage + ', approval=' + creditGR.approval);
                                
                                var creditSysId = creditGR.insert();
                                gs.info('SIGNATURE LOG: Created credit record ' + creditSysId + ' with auto-close attempt');
                                
                                // Double-check and update if needed
                                var checkGR = new GlideRecord('x_banun_bunow_si_0_credit_authority_limits');
                                if (checkGR.get(creditSysId)) {
                                    gs.info('SIGNATURE LOG: Re-checking credit record - state=' + checkGR.getValue('state') + ', stage=' + checkGR.getValue('stage') + ', approval=' + checkGR.getValue('approval'));
                                    
                                    if (checkGR.getValue('state') != '3' || checkGR.getValue('stage') != 'closed') {
                                        gs.info('SIGNATURE LOG: Credit state not correctly set, updating via update()');
                                        checkGR.state = 3;
                                        checkGR.stage = 'closed';
                                        checkGR.approval = 'approved';
                                        checkGR.update();
                                        gs.info('SIGNATURE LOG: Credit update completed');
                                    } else {
                                        gs.info('SIGNATURE LOG: Credit state was correctly set, no update needed');
                                    }
                                } else {
                                    gs.info('SIGNATURE LOG: ERROR - Could not retrieve credit record ' + creditSysId);
                                }
                            } else {
                                gs.info('SIGNATURE LOG: Changes detected for credit, normal insert');
                                creditGR.insert();
                            }
                        } else {
                            gs.info('SIGNATURE LOG: NEW request or no existing limits for credit, normal insert');
                            creditGR.insert();
                        }
                    }
                } catch (e) {
                    gs.addErrorMessage('Error processing authority data: ' + e.message);
                    gs.info('SIGNATURE LOG: ERROR processing authority data: ' + e.message);
                }
            }
        }
    }
}

gs.info('SIGNATURE LOG: Script completed');
